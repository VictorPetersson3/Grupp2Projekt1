using System.Collections;
using System.Collections.Generic;
using UnityEngine;

[DisallowMultipleComponent]
[RequireComponent(typeof(PathCreator))]
[RequireComponent(typeof(MeshFilter))]
[RequireComponent(typeof(MeshRenderer))]
[ExecuteInEditMode]

public class MeshCreator : MonoBehaviour
{
    [Range(0.05f, 1.5f)]
    public float spacing = 1;
    public float meshHeigth = 1;
    public float meshWidth = 1f;
    //[HideInInspector]
    public bool previewGeneratedMesh;
    public float uvTiling = 1;
    public Material material;
    Mesh previewMesh;

    public void UpdateMesh()
    {
        Path path = GetComponent<PathCreator>().path;
        Vector2[] points = path.CalculateEvenlySpacedPoints(spacing);
        previewMesh = CreateMesh(points, path.IsClosed);
        GetComponent<MeshFilter>().mesh = previewMesh; 
        GetComponent<MeshRenderer>().material = material;
        int textureRepeat = Mathf.RoundToInt(uvTiling * points.Length * spacing * 0.5f);
    }
    public void CreateMesh()
    {
        CreateGameObject("generated by" + GetType().Name);
    }
    Mesh CreateMesh(Vector2[] points, bool isClosed)
    {
        Vector3[] vertices = new Vector3[points.Length * 2];
        Vector3[] reCastVertices = new Vector3[points.Length * 2];
        Vector2[] uvs = new Vector2[vertices.Length];
        int numbTriangles = 2 * (points.Length - 1) + ((isClosed) ? 2 : 0);
        int[] triangles = new int[numbTriangles * 3];
        int vertexIndex = 0;
        int triangleIndex = 0;

        for (int i = 0; i < points.Length; i++)
        {
            Vector2 forward = Vector2.zero;
            if (i < points.Length - 1 || isClosed)
            {
                forward += points[(i + 1) % points.Length] - points[i];
            }
            if (i > 0 || isClosed)
            {
                forward += points[i] - points[(i - 1 + points.Length) % points.Length];
            }
            forward.Normalize();
            Vector2 left = new Vector2(-forward.y, forward.x);
            
            //Create Vertices
            vertices[vertexIndex] = points[i] + left * meshHeigth * 0.5f;
            vertices[vertexIndex + 1] = points[i] - left * meshHeigth * .5f;
            
            //Adding Z as a changeable variable
            vertices[vertexIndex].z = meshWidth;
            vertices[vertexIndex + 1].z = -meshWidth;

            float pathCompletionPercent = i / (float)(points.Length - 1);
            float v = 1 - Mathf.Abs(2 * pathCompletionPercent - 1);
            uvs[vertexIndex] = new Vector2(0, v);
            uvs[vertexIndex + 1] = new Vector2(1, v);
            //Updating V to be scaled based on lenght of spline
            uvs[vertexIndex].y *= uvTiling * points.Length * spacing * 0.5f;
            uvs[vertexIndex +1].y *= uvTiling * points.Length * spacing * 0.5f;

            //Create triangles
            if (i < points.Length - 1 || isClosed)
            {
                triangles[triangleIndex] = vertexIndex;
                triangles[triangleIndex + 1] = (vertexIndex + 2) % vertices.Length;
                triangles[triangleIndex + 2] = vertexIndex + 1;

                triangles[triangleIndex + 3] = vertexIndex + 1;
                triangles[triangleIndex + 4] = (vertexIndex + 2) % vertices.Length;
                triangles[triangleIndex + 5] = (vertexIndex + 3) % vertices.Length;
            }
            vertexIndex += 2;
            triangleIndex += 6;
        }
        //write vectors to a new mesh
        Mesh mesh = new Mesh();
        mesh.vertices = vertices;
        mesh.triangles = triangles;
        mesh.uv = uvs;
        mesh.RecalculateNormals();
        mesh.RecalculateTangents();

        return mesh;
    }


    private GameObject CreateGameObject(string name)
    {
        Path path = GetComponent<PathCreator>().path;
        Vector2[] points = path.CalculateEvenlySpacedPoints(spacing);
        GameObject newGameObject;
        
        newGameObject = MeshUtility.Create(name,
            this.gameObject,
            typeof(MeshFilter),
            typeof(MeshRenderer),
            typeof(Renderer));
        newGameObject.isStatic = true;
       
        newGameObject.transform.SetParent(transform);
        Mesh newMesh = CreateMesh(points, path.IsClosed);
        newGameObject.GetComponent<MeshRenderer>().material = material;
        newGameObject.GetComponent<MeshFilter>().mesh = newMesh;

        int textureRepeat = Mathf.RoundToInt(uvTiling * points.Length * spacing * 0.5f);
        return newGameObject;


    }

}
